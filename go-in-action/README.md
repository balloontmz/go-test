# go in action

## chapter-3

[go 环境配置--自动补全等](https://zhuanlan.zhihu.com/p/36453771)

`go env`

```shell
echo "github.com/nsf/gocode
github.com/uudashr/gopkgs/cmd/gopkgs
github.com/ramya-rao-a/go-outline
github.com/acroca/go-symbols
golang.org/x/tools/cmd/guru
golang.org/x/tools/cmd/gorename
github.com/fatih/gomodifytags
github.com/haya14busa/goplay/cmd/goplay
github.com/josharian/impl
github.com/rogpeppe/godef
sourcegraph.com/sqs/goreturns
github.com/golang/lint/golint
github.com/cweill/gotests/gotests
github.com/derekparker/delve/cmd/dlv" | xargs go get -u -v
```

nil 切片和空切片

```go
// nil 切片
var slice []int

// 空切片
slice := make([]int, 0)

slice := []int{}
```

### 创建切片时的 3 个索引
创建切片时第三个索引用于指定生成的切片的容量--作用：当扩展切片时，不会改变原切片的数组，而是重新生成一个原始数组
`slice := source[2:3:4]`

如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个 append 操作 创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行 后续修改.

range 遍历返回的是当前遍历元素的副本，该值的指针总是指向相同的地址，如果需要该元素的地址，应该采用 索引进行获取

切片遍历总是从头部开始，所以是有序的？？？map 是无序的吧。。。

### 在函数间传递切片
在函数间传递切片就是要在函数间以值的方式传递切片。由于切片的尺寸很小，在函数间复 制和传递切片成本也很低。

### 在函数间传递映射
在函数间传递映射并不会制造出该映射的一个副本。实际上，当传递映射给一个函数，并对 这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改。


### 小结
```
数组是构造切片和映射的基石。
Go 语言里切片经常用来处理数据的集合，映射用来处理具有键值对结构的数据。 
内置函数 make 可以创建切片和映射，并指定原始的长度和容量。也可以直接使用切片
和映射字面量，或者使用字面量作为变量的初始值。
切片有容量限制，不过可以使用内置的 append 函数扩展容量。 映射的增长没有容量或者任何限制。
内置函数 len 可以用来获取切片或者映射的长度。
内置函数 cap 只能用于切片。 
通过组合，可以创建多维数组和多维切片。也可以使用切片或者其他映射作为映射的值。但是切片不能用作映射的键。 
将切片或者映射传递给函数成本很小，并且不会复制底层的数据结构。
```

## chapter-5 

### 引用类型
Go 语言里的引用类型有如下几个:切片、映射、通道、接口和函数类型。当声明上述类型的变量时，创建的变量被称作标头(header)值。从技术细节上说，字符串也是一种引用类型。 每个引用类型创建的标头值是包含一个指向底层数据结构的指针。每个引用类型还包含一组独特 的字段，用于管理底层数据结构。因为标头值是为复制而设计的，所以永远不需要共享一个引用 类型的值。标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本质上就是 在共享底层数据结构。

是使用值接收者还是指针接收者，不应该由该方法是否修改了接收到的值来决定。这个决策 应该基于该类型的本质。这条规则的一个例外是，需要让类型值符合某个接口的时候，即便类型 的本质是非原始本质的，也可以选择使用值接收者声明方法。这样做完全符合接口值调用方法的 机制。5.4 节会讲解什么是接口值，以及使用接口值调用方法的机制。

嵌入类型、未公开的标识符。

嵌入类型的属性和方法会提升到最外层，如果

使用关键字 struct 或者通过指定已经存在的类型，可以声明用户定义的类型。 
方法提供了一种给用户定义的类型增加行为的方式。 
设计类型时需要确认类型的本质是原始的，还是非原始的。 
接口是声明了一组行为并支持多态的类型。 
嵌入类型提供了扩展类型的能力，而无需使用继承。 
标识符要么是从包里公开的，要么是在包里未公开的。

## chapter-6

### 竞争状态
`go build -race // 用竞争检测器标志来编译程序`